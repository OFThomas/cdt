\documentclass[12pt]{article}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  Packages  %%%%%%%%%%%%%
\usepackage{amsmath} 
\usepackage{mathtools}
\usepackage{physics}
\usepackage{amssymb}
\usepackage{mathptmx}
\usepackage{array}

%%%%%%%%% FIGurES %%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{textcomp}
\usepackage{graphicx}
\usepackage{caption} 
\usepackage{subcaption}
\usepackage{scrextend}
\usepackage{pgfgantt}
\usepackage{rotating}
\usepackage{subcaption}
\usepackage{scrextend}
\usepackage{float}
%\graphicspath{ {figures/} }
\usepackage{hyperref}
\hypersetup{colorlinks=true, citecolor=blue, linkcolor=blue}
\renewcommand{\equationautorefname}{Eq.}%
\renewcommand{\figureautorefname}{Fig.}%

%%%%%%%%%%%% LaNgUaGe %%%%%%%%%%%%%%%%%%
\usepackage[latin1]{inputenc}
\usepackage{verbatim}
\usepackage{natbib}

%%%%%%%%%%%%%%%%%% Custom maths shortcuts %%%%%%%%%
\newcommand{\ident}{\[ \mathds{1} \]}

\renewcommand{\vec}[1]{\mathbf{#1}}
\newcommand{\squeezeup}{\vspace{-2.5mm}}
\newcommand{\rtwo}{\sqrt{2}}
%\DeclarePairedDelimiter\abs{\lvert}{\rvert}%
%\newcommand{\ket}[1]{\left| #1 \right\rangle}
%\newcommand{\bra}[1]{\left\langle #1 \right|}

\usepackage{qcircuit}
\usepackage{pdflscape}
\usepackage{afterpage}
\usepackage{wrapfig}
\usepackage[a4paper]{geometry}
\usepackage{multicol}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newgeometry{left=0.8in,right=0.8in,top=1in,bottom=1in}
%%%%%%%%%%%%%%%%%%%%%%%%% EnD oF pAcKaGeS %%%%%%%%%%%%%%%%

\begin{document} %WOOP WOOP!
% Title page 

    \title{Quantum Circuits for the Schur Transform}
    \author{Oliver Thomas \\[0.5em] \\ Quantum Engineering CDT \\ University of Bristol}
    \date{\today}
    \maketitle

\section{The Schur Transform}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{itemize}
	\item schur transform
	\item streaming
	\item clebsch gordan
	\item vanilla CG
	\item vanilla for 3,4
	\item registered
	\item general scheme
	\item comments
\end{itemize}

\textit{background.}

2004 Bacon, Chuang \& Harrow proposed a scheme for implementing the Schur transform in Poly time. 

Information processing tasks, such as classical compression gain a huge advantage implementing the process using a streaming scheme. Rather than start the compression on all the data to be sent and wait for it all to
be compressed then send the data, as compression can be performed sequentially, compress part of the message and send it while compressing the next part. The Schur transform can also be thought of in this way. However,
with compression it can still be useful to only compress part of the message, it is meaningless to perform only part of the Schur transform which suggests there may be a more optimal scheme opposed to streaming for 
implementing the Schur transform.      

There are two distinct ways of performing the Schur transform on $n$ qubits, it can either be built up from coupling all $n$ qubits together in a single iteration which we call the spatial multiplexed approach. The
other approach is performing Clebsch-Gordan (CG) transforms on the $n$ qubits one at a time which we call the temporal multiplexed approach.  


This report is structured as follows,   


\section{Streaming Scheme}

The streaming Schur transform is described in \autoref{fig:stream},

\begin{figure}[h!]
\centering
\includegraphics[width=0.4\textwidth]{schurcascade.png}
\caption{Streaming structure where the Schur transform is built up from consecutive Clebsch-Gordan transforms \cite{bacon2006efficient}.}
\label{fig:stream}
\end{figure}

For the streaming scheme the $U_{CG}$ block can be chosen so that it contains all of the gates for upto the n-th qubit meaning the same block can be repeated. Where the $U_{CG}$ is the Clebsch-Gordan transform between the $J$ \& $M$ registers and the k-th qubit $\ket{i_k}$.


\begin{figure}[h!]
\centering
\includegraphics[width=0.4\textwidth]{genaddercirc.png}
\caption{$U_{CG}$ block, Qadder, controlled rotation, Qadder \cite{bacon2006efficient}.}
\label{fig:ucg}
\end{figure}

The controlled Rotation matrix, $R_y(\theta_{J,m'})$ \autoref{fig:stream} is the Clebsch-Gordan coefficients for coupling 1 qubit sequentially, given by,
\begin{align}
\begin{split}
R_y(\theta_{J,m'})=
\begin{bmatrix}
\cos(\theta_{J,m'}) &-\sin(\theta_{J,m'}) \\
\sin(\theta_{J,m'}) & \cos(\theta_{J,m'}) \\
\end{bmatrix}
\end{split}
=
\begin{split}
\frac{1}{\sqrt{2J+1}}
\begin{bmatrix}
\sqrt{J+\frac{1}{2}+m'} &-\sqrt{J+\frac{1}{2}-m'} \\
\sqrt{J+\frac{1}{2}-m'} & \sqrt{J+\frac{1}{2}+m'} \\
\end{bmatrix}
\end{split}
\label{eq:rotmatrix}
\end{align}

Where primed variables means after the angular momentum addition so $J$ is the total J that the spin is coupling to, the system will have $J'$ total angular momentum after the coupling. $m$ is the z component of the system before and $m'$ is the total z component after the coupling.

To build this circuit the rotation matrix, $R_y(\theta_{J,m'})$ needs to be calculated using \autoref{eq:rotmatrix}, values here \autoref{eq:rvalues}, and a function to update the $\ket{m}$ and $\ket{J}$ registers is needed. Updating the registers can be implemented relatively simply using the coherent (meaning the registers are allowed to be in superpositions) equivalent of the digital full adders and subtractors. The complexity now has been reduced to implementing the Clebsch-Gordan transform, $U_{CG}$.

The aim of this report is to look at whether it is possible to achieve a log decrease in time by instead of coupling 1 qubit in at a time to the $J$ \& $M$ registers, to pairing the couplings up in a \textbf{binary tree?} technique. To investigate the problem we look at how the complexity of performing the Clebsch-Gordan transform scales moving from coupling a single qubit to an arbitrary $J \& M$ to coupling arbitrary $J \& M$ registers together. looking at the pairing approach there is a symmetry in the fact that the max range of $J \& M$ values will be the same within each pairing which will help simplify the problem
compared to any arbitrary $J \& M$ values.


\section{Implementing the Clebsch-Gordan Transform}

The vanilla transform directly maps the computation basis states to a labeling of J and M values. The vanilla approach of calculating the CG coefficients and finding a gate decomposition does not scale well. A better approach is to use a scheme explicitly storing the values of J \& M in a register.

%%%%%%%%%%%%%% 2 qubits
\subsection{Clebsch-Gordan transform for 2 qubits}

The Clebsch-Gordan transform is a basis transformation into the Schur basis. The transform for 2 qubits is given by,
\begin{subequations}
\begin{align}
\begin{split}
&\ket{J=1, M=+1} = \ket{00} \\
&\ket{J=1, M=\;\;\;0} = \frac{1}{\sqrt{2}}(\ket{01} + \ket{10}) \\
&\ket{J=1, M=-1} = \ket{11} \\
\end{split}\\
\begin{split}
&\ket{J=0, M=\;\;\;0} = \frac{1}{\sqrt{2}}(\ket{01} - \ket{10})\\
\end{split}
\end{align}
\end{subequations}

Throughout the encoding $\ket{0}=+1/2$, $\ket{1}=-1/2$ is used unless stated otherwise.

The transform expressed as a matrix is,
\begin{align}
\begin{bmatrix}
1 & 0 & 0 & 0 \\
0 & \frac{1}{\sqrt{2}} & \frac{1}{\sqrt{2}} & 0 \\
0 & 0 & 0 & 1 \\
0 & \frac{1}{\sqrt{2}} & -\frac{1}{\sqrt{2}} & 0 \\
\end{bmatrix}
\begin{bmatrix}
\ket{00} \\
\ket{01} \\
\ket{10} \\
\ket{11} \\ 
\end{bmatrix}
= \text{(spin labeling)}
\begin{bmatrix}
\ket{00} \\
\frac{1}{\sqrt{2}}(\ket{01} + \ket{10}) \\
\ket{11} \\
\frac{1}{\sqrt{2}}(\ket{01} - \ket{10}) \\ 
\end{bmatrix}
=
\begin{bmatrix}
\ket{J=1, M=1} \\
\ket{J=1, M=0} \\
\ket{J=1, M=-1} \\
\ket{J=0, M=0} \\ 
\end{bmatrix}
\end{align}


\subsubsection{Clebsch-Gordan coefficients for 3 qubits}

The CG coefficients for three qubits are no multiplicities of 4 for J=3/2 and 2 multiplicities of 2 for J=1/2  \autoref{eq:3cgcoeff}. The multiplicities, P are defined as $J'-J$ the new J value minus the previous J value, the number of 1s in a P string is the number of multiplicities for that J value.

%%%%%%%%%%%%%%% vanilla basis %%%%%%%%%%%%%%%%%%5

The matrix for the transform which takes the computational basis to the spin basis is,
There are multiple ways of writing the spin basis, there is the traditional CG coefficients and there is also what is referred to here as the phase encoding \autoref{eq:phaseencode}. The phase encoded transform matrix will have a different decomposition as the shape of the matrix is different to the regular encoding. 


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



\subsubsection{4 Qubit CG coefficients}

The CG coefficients for four qubits contains 16 terms, 5 for J=2, 3 multiplicities of 3 for J=1, 2 multiplicities of 1 for J=0. The equations are given in \autoref{eq:4qubitcg}. In the J=1 case there are 3 acceptable bit strings, 0001, 0010, 0100 meaning there are 3 multiplicities present. 

\subsection{Glebsch-Gordan circuits}

As two-qubit (entangling) gates are much more expensive to perform compared to single qubit gates, the cost of the circuits discussed here will all be given in terms of the number of two-qubit gates. The decomposition scheme for the n-qubit case could take at most $2^{n-1}(2^n-1)$ $C^{n-1}U$ gates \cite{li2013decomposition}, where $C^{n-1}U$ means a unitary acting on 1 qubit controlled on the other n-1 qubits.

\subsubsection{2 qubit circuit}

Which can be implemented in a circuit as,
%%%%%%%%% circuit 1 
\begin{figure}[h]
\begin{align}
\Qcircuit @C=0.5cm @R=0.7cm{
%1
&\lstick{S_1} &\gate{H} &\ctrl{1} &\qw \\
%0
&\lstick{S_0} &\ctrl{-1} &\targ &\qw \\
}
\end{align}
\caption{Schur transform for 2 qubits}
\label{cir:vanilla2}
\end{figure}

Circuit for Clebsch-Gordan transform \autoref{cir:vanilla2} contains 2 gates.

\subsubsection{Circuit for 3 qubit transform}

For 3 qubits this upper bound is 128 $C^2U$ gates. It has been shown that in terms of gate count, $C^nU \sim 5 C^{n-1}V$ where $U \& V$ are unitaries \cite{barenco1995elementary}. This means the maximum two-qubit gates needed would be 140 $CU$ gates.

The decomposition of the 3 qubit CG transform was performed using the Givens rotation method for unitary decomposition into a gate-set. The matrix \autoref{eq:3qubitcg} can be expressed as a product of 19 $C^2U$ gates (control-control-unitaries) which is $\sim$80 $CU$ gates. 

See online \cite{githubot561} for Fortran code which implements the Givens rotation method to give the 19 $C^2U$ gate decomposition. The majority of the gates are CNOT gates. This is mainly due to the re-ordering of the basis and is similar to the quantum Fourier transform (QFT). The QFT produces the output in reverse qubit order the actual number of gates required to do the transform is massively reduced. The overhead calculated here is due to the rearranging of the basis. This means that depending on what the transform is used the transform could be computed with less gates. For example, if the transform was only used to check if the state was in a particular J block but didn't need to know the specific M value the order afterwards wouldn't be as important reducing the CNOTs needed.

\subsubsection{Circuit for 4 qubit transform}

The decomposition scheme for the 4 qubit case could take at most $2^{n-1}(2^n-1)$ $C^{n-1}U$ gates \cite{li2013decomposition}, where n is 4 and. For 4 qubits this upper bound is 120 $C^3U$ gates which could be up to $\sim 3000$ $CU$ gates. In reality it will be much fewer gates as the matrix is sparse, however this suggests a different approach was needed.


\section{General circuit for the Quantum Schur transform \autoref{cir:genstreaming}}


\subsection{Registering J \& M explicitly \autoref{cir:spatialmulti2}, \autoref{cir:minspatialmult}}

This spatial multiplexing approach only stores the final output values of the $J$ \& $M$ registers. 


Circuit uses the encoding for $\ket{S} : \ket{0} \mapsto Spin = +\frac{1}{2}, \ket{1} \mapsto Spin = -\frac{1}{2}$ and the same for $\ket{P}$. 

The circuit adds the value of the spin to be added, $\ket{S}$, to the M register to calculate the M' register value. This is done by implementing the quantum reversible equivalent to the digital full adder. 

\begin{wraptable}{r}{5.5cm}
\begin{tabular}{ |c c c|c| }
\hline
 $J_2$ &$J_1$ &$J_0$ &J \\
 \hline
 0 &0 &0 &0 \\ 
 0 &0 &1 &$\frac{1}{2}$ \\ 
 0 &1 &0 &1 \\ 
 0 &1 &1 &$\frac{3}{2}$ \\ 
 \hline 
 1 &0 &0 &-2 \\ 
 1 &0 &1 &-$\frac{3}{2}$ \\ 
 1 &1 &0 &-1 \\ 
 1 &1 &1 &-$\frac{1}{2}$ \\  
 \hline 
\end{tabular}
\caption{Binary Two's complement encoding to spin values of the J register}
\label{tab:encoding}
\vspace{-110pt}
\end{wraptable}

The streaming scheme uses temporal multiplexing to perform the Schur transform in polynomial time if a recursive streaming scheme is used \cite{bacon2007quantum}.


\section{Reduced general gate circuit for up to the 2 qubit Schur transform \autoref{cir:tempmultistream}}

We note that it is possible to reduce the gate count of the general streaming scheme by changing the encoding. Here we remove the intermediate values and hence can reduce both the number of qubits required and the gate count. This scheme works by coupling in two qubits at a time as opposed to one.


\section{Conclusion}

There is a lot of freedom in the choice of basis used. We have chosen to use Two's complement encoding for the registers. The encoding for the multiplicities remains consistent throughout althought it is more complex. For the general circuits the encoding remains consistent throughout. In order to achieve the optimal number of gates for the Schur transform on a specific number of qubits the encoding is changed on a case by case basis. 

Clebsch-Gordan for higher qubit numbers has redundancy in. depending on application of schur transform and input states it could be reasonable to approximate the transform when acting on highly symmetric states to just doing hadamard gates.


%%%%%%%%%%%%
\bibliographystyle{unsrt}
\bibliography{references}

\newpage
\input{appendmaths.tex}
\begin{landscape}
\input{appendcirc.tex}
\end{landscape}
\input{appendcode.tex}

\end{document}
