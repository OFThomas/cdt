\documentclass[12pt]{article}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  Packages  %%%%%%%%%%%%%
\usepackage{amsmath} 
\usepackage{mathtools}
\usepackage{physics}
\usepackage{amssymb}
\usepackage{mathptmx}
\usepackage{array}

%%%%%%%%% FIGurES %%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{textcomp}
\usepackage{graphicx}
\usepackage{caption} 
\usepackage{subcaption}
\usepackage{scrextend}
\usepackage{pgfgantt}
\usepackage{rotating}
\usepackage{subcaption}
\usepackage{scrextend}
\usepackage{float}
%\graphicspath{ {figures/} }
\usepackage{hyperref}
\hypersetup{colorlinks=true, citecolor=blue, linkcolor=blue}
\renewcommand{\equationautorefname}{Eq.}%
\renewcommand{\figureautorefname}{Fig.}%

%%%%%%%%%%%% LaNgUaGe %%%%%%%%%%%%%%%%%%
\usepackage[latin1]{inputenc}
\usepackage{verbatim}
\usepackage{natbib}

%%%%%%%%%%%%%%%%%% Custom maths shortcuts %%%%%%%%%
\newcommand{\ident}{\[ \mathds{1} \]}

\renewcommand{\vec}[1]{\mathbf{#1}}
\newcommand{\squeezeup}{\vspace{-2.5mm}}
\newcommand{\rtwo}{\sqrt{2}}
%\DeclarePairedDelimiter\abs{\lvert}{\rvert}%
%\newcommand{\ket}[1]{\left| #1 \right\rangle}
%\newcommand{\bra}[1]{\left\langle #1 \right|}

\usepackage{qcircuit}
\usepackage{pdflscape}
\usepackage{afterpage}
\usepackage{wrapfig}
\usepackage[a4paper]{geometry}
\usepackage{multicol}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newgeometry{left=0.8in,right=0.8in,top=1in,bottom=1in}
%%%%%%%%%%%%%%%%%%%%%%%%% EnD oF pAcKaGeS %%%%%%%%%%%%%%%%

\begin{document} %WOOP WOOP!
% Title page 

    \title{Quantum Circuits for the Schur Transform}
    \author{Oliver Thomas \\[0.5em] \\ Quantum Engineering CDT \\ University of Bristol}
    \date{\today}
    \maketitle

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Introduction}

There are many uses of the uses of the Schur transform, compression of local properties to a global system. in boson sampling experiments preparing highly symmetrerised states, \cite{moylett2018quantum}. 
We look at existing algorithms for implementing the Schur transform and aim to produce a minimal gate quantum circuit which in principle could be used to implement the Schur transform on a small number of qubits in the near future \cite{kirby2017practical}.

There are two distinct ways of performing the Schur transform on $n$ qubits, it can either be built up from coupling all $n$ qubits together in a single iteration which we call the spatial multiplexed approach. The
other approach is performing Clebsch-Gordan (CG) transforms on the $n$ qubits one at a time which we call the temporal multiplexed approach.  

This report is structured as follows, the Schur transform is introduced and we construct a quantum circuit using the Givens rotation method \cite{li2013decomposition}. We comment on the scalability of this method and compare it to the streaming procedure suggested by BCH \cite{bacon2006efficient}. 2004 Bacon, Chuang \& Harrow proposed a scheme for implementing the Schur transform in Poly time. 

\section{Schur transform}

The Schur transform maps the computation basis states to a Schur basis, in the qubit case this corresponds to performing a Clebsch-Gordan transform. There are different ways of defining a Schur basis but here we choose to use angular momentum, defined in terms of a labeling of J (Total angular momentum values), M (z-axis projection of the angular momentum) and multiplicity values which we refer to as P.

The Schur basis vectors for two qubits are,

\begin{subequations}
\begin{align}
\begin{split}
&\ket{J=1, M=+1} = \ket{00} \\
&\ket{J=1, M=\;\;\;0} = \frac{1}{\sqrt{2}}(\ket{01} + \ket{10}) \\
&\ket{J=1, M=-1} = \ket{11} \\
\end{split}\\
\begin{split}
&\ket{J=0, M=\;\;\;0} = \frac{1}{\sqrt{2}}(\ket{01} - \ket{10})\\
\end{split}
\end{align}
\end{subequations}

We have suppressed the multiplicity label here for simplicity as there are no multiplicities in the two qubit case. The matrix for the transform which takes the computational basis to the spin basis is,

\begin{align}
\begin{bmatrix}
1 & 0 & 0 & 0 \\
0 & \frac{1}{\sqrt{2}} & \frac{1}{\sqrt{2}} & 0 \\
0 & 0 & 0 & 1 \\
0 & \frac{1}{\sqrt{2}} & -\frac{1}{\sqrt{2}} & 0 \\
\end{bmatrix}
\begin{bmatrix}
\ket{00} \\
\ket{01} \\
\ket{10} \\
\ket{11} \\ 
\end{bmatrix}
=
\begin{bmatrix}
\ket{00} \\
\frac{1}{\sqrt{2}}(\ket{01} + \ket{10}) \\
\ket{11} \\
\frac{1}{\sqrt{2}}(\ket{01} - \ket{10}) \\ 
\end{bmatrix}
=
\begin{bmatrix}
\ket{J=1, M=1} \\
\ket{J=1, M=0} \\
\ket{J=1, M=-1} \\
\ket{J=0, M=0} \\ 
\end{bmatrix}
\end{align}

This transform takes the computational basis state, $\ket{01}$ to a superposition of the singlet and triplet states, $\frac{1}{\sqrt{2}} (\ket{J=1, M=0} + \ket{J=0, M=0})$. 

The Schur basis vectors can be calculated for any n qubit couplings using the Glebsch-Gordan coefficients, here we have calculated up to 4 qubits. For more than two qubits multiplicities are introduced, multiplicities keep track of which subspace the system is in. The multiplicities, P are defined as $J'-J$ the new J value minus the previous J value, the number of combinations for a given amount of 1s in a P string is the number of multiplicities for that J value.

The transform for three qubits contains 8 terms, the allowed J values are J=3/2 which contains 4 states and J=1/2 which contains 2 states. The J=1/2 subspace contains 2 multiplicities corresponding to the two possible routes to that coupling, either J=1 to J=1/2 (couple down) or J=0 to J=1/2 (couple up). The basis vectors are given in the appendix for completeness \autoref{eq:3cgcoeff}. There are multiple ways of writing the spin basis vectors, the traditional C-G coefficients and also what we refer to as the phase encoding \autoref{eq:phaseencode}. The phase encoded transform matrix will have a different decomposition as the shape of the matrix is different to the regular encoding. 

The transform for four qubits contains 16 terms, J=2 contains 5 terms, J=1 contains 3 terms with 3 multiplicities and the J=0 contains 1 term with 2 multiplicities. The equations are given in \autoref{eq:4qubitcg}. In the J=1 subspace there are 3 acceptable bit strings containing a single one, 0001, 0010 and 0100. This means there are 3 multiplicities present. 

\subsection{Schur Transform circuits}

After building the unitary matrices from the Schur basis vectors using the CG coefficients we now calculate the gate cost of implementing the unitaries for 2, 3 and 4 qubits. See online \cite{githubot561} for Fortran code which implements the Givens rotation method to give the $C^{n-1}U$ decomposition for each of the Schur transform unitaries. 

As two-qubit (entangling) gates are much more expensive to perform compared to single qubit gates, the cost of the circuits discussed here will all be given in terms of the number of two-qubit gates. The decomposition scheme for the n-qubit case is bounded by $2^{n-1}(2^n-1)$ $C^{n-1}U$ gates \cite{li2013decomposition}, where $C^{n-1}U$ means a unitary acting on 1 qubit controlled on the other n-1 qubits. When n is greater than 2, it is possible to reduce higher order control gates to single control gates, $C^nU \sim 5 C^{n-1}V$ where $U \& V$ are unitaries \cite{barenco1995elementary}.

The two qubit Schur transform can be implemented in a circuit which only contains two gates as \autoref{cir:vanilla2},

%%%%%%%%% circuit 1 
\begin{figure}[h]
\begin{align}
\Qcircuit @C=0.5cm @R=0.7cm{
%1
&\lstick{S_1} &\gate{H} &\ctrl{1} &\qw \\
%0
&\lstick{S_0} &\ctrl{-1} &\targ &\qw \\
}
\end{align}
\caption{Schur transform for 2 qubits}
\label{cir:vanilla2}
\end{figure}

For 3 qubits this upper bound is 28 $C^2U$ gates.This means the maximum two-qubit gates needed would be 140 $CU$ gates. The decomposition of the 3 qubit CG transform was performed using the Givens rotation method for unitary decomposition into a gate sequence. The matrix \autoref{eq:3qubitcg} can be expressed as a product of 19 $C^2U$ gates (control-control-unitaries) which is $\sim$80 $CU$ gates. 

The decomposition scheme for the 4 qubit case the upper bound is 120 $C^3U$ gates which could be up to $\sim 3000$ $CU$ gates. The 4 qubit Schur transform requires 72 $C^3U$ gates which is equal to $\sim 1800 CU$ gates. This suggests a different approach was needed.

The 2 qubit case 1 out of 2 gates are CNOTs, 3 qubits, 14 out of 15 are $C^2$NOTs and 4 qubits, 50 out of 72 are $C^3$-NOT gates. 

\section{Streaming Scheme}

Entanglement purification is an example of a process which gains an advantage when using a streaming scheme \cite{blume2014streaming}. Rather than wait for all of the entangled resource to be purified, it is possible to optimally perform purification in a streaming setup, send some of the purified resource while purifying the rest continually. The streaming scheme for the Schur transform can also be thought of in this way. However, it can still be useful to only purify part of the resource, it is not useful to only be able to  perform a partial Schur transform which suggests there may be other equivalent or better methods compared to streaming for implementing the Schur transform.      

We look at whether it is possible to achieve decrease in time by instead of coupling 1 qubit in at a time to the $J$ \& $M$ registers, to pairing each of the couplings up similar to a binary tree. To investigate the problem we look at how the complexity of performing the Clebsch-Gordan transform scales moving from coupling a single qubit to an arbitrary $J \& M$ to coupling arbitrary $J \& M$ registers together. The pairing approach has a symmetry in the max range of $J \& M$ values will be the same within each pairing which will help simplify the problem compared to any arbitrary $J \& M$ values.

\begin{figure}[h!]
\centering
\includegraphics[width=0.5\textwidth]{schurcascade.png}
\caption{Streaming structure where the Schur transform is built up from consecutive Clebsch-Gordan transforms \cite{bacon2006efficient}.}
\label{fig:stream}
\end{figure}

For the streaming scheme \autoref{fig:stream} the $U_{CG}$ block can be chosen so that it contains all of the gates for up to the n-th qubit meaning the same block can be repeated. Where the $U_{CG}$ is the Clebsch-Gordan transform between the $J$ \& $M$ registers and the k-th qubit $\ket{i_k}$.

\begin{figure}[h!]
\centering
\includegraphics[width=0.4\textwidth]{genaddercirc.png}
\caption{$U_{CG}$ block, Qadder, controlled rotation, Qadder \cite{bacon2006efficient}.}
\label{fig:ucg}
\end{figure}

The controlled Rotation matrix \cite{bacon2006efficient}, $R_y(\theta_{J,m'})$ \autoref{fig:ucg} is the Clebsch-Gordan coefficients for coupling 1 qubit sequentially,

\begin{align}
\begin{split}
R_y(\theta_{J,m'})=
\begin{bmatrix}
\cos(\theta_{J,m'}) &-\sin(\theta_{J,m'}) \\
\sin(\theta_{J,m'}) & \cos(\theta_{J,m'}) \\
\end{bmatrix}
\end{split}
=
\begin{split}
\frac{1}{\sqrt{2J+1}}
\begin{bmatrix}
\sqrt{J+\frac{1}{2}+m'} &-\sqrt{J+\frac{1}{2}-m'} \\
\sqrt{J+\frac{1}{2}-m'} & \sqrt{J+\frac{1}{2}+m'} \\
\end{bmatrix}
\end{split}
\label{eq:rotmatrix}
\end{align}

Where primed variables means after the angular momentum addition so $J$ is the total J that the spin is coupling to, the system will have $J'$ total angular momentum after the coupling. $m$ is the z component of the system before and $m'$ is the total z component after the coupling.

To build this circuit the rotation matrix, $R_y(\theta_{J,m'})$ needs to be calculated using \autoref{eq:rotmatrix}, values here \autoref{eq:rvalues}, and a function to update the $\ket{m}$ and $\ket{J}$ registers is needed. Updating the registers can be implemented relatively simply using the coherent (meaning the registers are allowed to be in superpositions) equivalent of the digital full adders and subtractors. The complexity now has been reduced to implementing the Clebsch-Gordan transform, $U_{CG}$.

\section{General circuit for the Quantum Schur transform \autoref{cir:genstreaming}}

In the section above we have investigated the cost of implementing directly the Clebsch-gordan unitary matrix using a unitary gate decomposition scheme. We note that the majority, over half of the gates are CNOT or higher dimensional equivalents.

We now compare directly decomposing the Schur transform unitary to the streaming scheme above, the streaming method has the advantage of being modular and relatively easy to calculate. Calculating the circuits was done by calculating the truth tables for each step, the quantum adder which can be implemented reversibly, \cite{draper2004logarithmic} and other possibly more optimal schemes for very large registers which makes use of the quantum Fourier transform, \cite{draper2000addition} which are outside the scope of this work.


\subsection{Registering J \& M explicitly \autoref{cir:spatialmulti2}, \autoref{cir:minspatialmult}}

This spatial multiplexing approach only stores the final output values of the $J$ \& $M$ registers. 

Circuit uses the encoding for $\ket{S} : \ket{0} \mapsto Spin = +\frac{1}{2}, \ket{1} \mapsto Spin = -\frac{1}{2}$ and the same for $\ket{P}$. 

The circuit adds the value of the spin to be added, $\ket{S}$, to the M register to calculate the M' register value. This is done by implementing the quantum reversible equivalent to the digital full adder. 

\begin{wraptable}{r}{5.5cm}
\begin{tabular}{ |c c c|c| }
\hline
 $J_2$ &$J_1$ &$J_0$ &J \\
 \hline
 0 &0 &0 &0 \\ 
 0 &0 &1 &$\frac{1}{2}$ \\ 
 0 &1 &0 &1 \\ 
 0 &1 &1 &$\frac{3}{2}$ \\ 
 \hline 
 1 &0 &0 &-2 \\ 
 1 &0 &1 &-$\frac{3}{2}$ \\ 
 1 &1 &0 &-1 \\ 
 1 &1 &1 &-$\frac{1}{2}$ \\  
 \hline 
\end{tabular}
\caption{Binary Two's complement encoding to spin values of the J register}
\label{tab:encoding}
\vspace{-100pt}
\end{wraptable}

The streaming scheme uses temporal multiplexing to perform the Schur transform in polynomial time if a recursive streaming scheme is used \cite{bacon2007quantum}.

\section{Reduced general gate circuit for up to the 2 qubit Schur transform \autoref{cir:tempmultistream}}

We note that it is possible to reduce the gate count of the general streaming scheme by changing the encoding. Here we remove the intermediate values and hence can reduce both the number of qubits required and the gate count. This scheme works by coupling in two qubits at a time as opposed to one.

\section{Conclusion}

The majority of the gates are CNOT gates. This is mainly due to the re-ordering of the basis and is similar to the quantum Fourier transform (QFT). The QFT produces the output in reverse qubit order the actual number of gates required to do the transform is massively reduced. The overhead calculated here is due to the rearranging of the basis. This means that depending on what the transform is used the transform could be computed with less gates. For example, if the transform was only used to check if the state was in a particular J block but didn't need to know the specific M value the order afterwards wouldn't be as important reducing the CNOTs needed.

There is a lot of freedom in the choice of basis used. We have chosen to use Two's complement encoding for the registers. The encoding for the multiplicities remains consistent throughout although it is more complex. For the general circuits the encoding remains consistent throughout. In order to achieve the optimal number of gates for the Schur transform on a specific number of qubits the encoding is changed on a case by case basis. 

For large qubit coupling numbers the R matrix in the UCG tends to a Hadamard gate for the $\abs{M} < \abs{J}$ values of M. This means that depending on application of Schur transform and input states, it could be reasonable to approximate the transform when acting on highly symmetric states to just doing Hadamard gates.


%%%%%%%%%%%%
\bibliographystyle{unsrt}
\bibliography{references}

\newpage
\input{appendmaths.tex}
\begin{landscape}
\input{appendcirc.tex}
\end{landscape}
\input{appendcode.tex}

\end{document}
